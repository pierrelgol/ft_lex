#include <stdint.h>
#include <stdio.h>
#include <string.h>


static const int16_t yy_acclist[11] = {
   +0,   +27,    +0,    +0,    +0,    +0,    +0,   +31,   +34,    +0, 
   +0, 
};

static const int32_t yy_accept[37] = {
   +0,   +10,    +4,    +5,    +1,   +10,    +0,    +0,    +0,    +9, 
   +9,    +9,    +4,    +5,    +8,    +7,    +6,    +9,    +0,    +0, 
   +0,    +0,    +3,    +0,    +2,    +0,    +0,    +0,    +1,    +0, 
   +0,    +0,    +7,    +0,    +0,    +8,    +0, 
};

static const uint8_t yy_ec[256] = {
    0,     1,     1,     1,     1,     1,     1,     1,     1,     2, 
    3,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     4,     1,     5,     6,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     7,     7, 
    7,     7,     7,     7,     7,     7,     7,     7,     1,     8, 
    1,     9,     1,     1,     1,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,     1,     1,     1,     1,    10,     1,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,    10,    10,    10,    10,    10,    10,    10, 
   10,    10,    10,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1,     1,     1,     1,     1, 
    1,     1,     1,     1,     1,     1, 
};

static const int16_t yy_base[37] = {
   +0,    +7,    +0,    +0,    +0,    +0,    +3,    +0,   +15,   +25, 
  +33,    +5,   +35,    +0,    +0,    +0,    +0,    +0,    +0,    +0, 
   +0,   +16,    +0,   +22,   +41,    +0,    +0,   +28,   +48,   +35, 
   +0,   +46,   +51,    +0,   +46,   +49,    +0, 
};

static const int16_t yy_default[37] = {
   +2,    -1,    -1,    -1,    -1,    -1,    -1,    +1,   +12,    -1, 
   -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   +11,   +10, 
   +9,    -1,    -1,    +0,    -1,    +8,   +21,    -1,   +27,    -1, 
   -1,    -1,   +31,    -1,    -1,   +34,    -1, 
};

static const int16_t yy_next[62] = {
   -1,    +5,    +2,    +3,    +2,    +5,    +5,    +5,    +5,    +5, 
   +1,    +6,    +4,   +14,    +7,   +18,   +17,    +7,   +13,   +22, 
   +9,   +17,   +10,   +17,   +17,   +11,   +20,   +20,   +24,   +20, 
  +16,   +20,   +20,   +20,   +20,   +20,   +15,   +12,   +28,   +12, 
  +19,   +15,   +24,   +24,   +30,   +24,   +24,   +24,   +24,   +24, 
  +24,   +24,   +29,   +32,   +33,   +28,   +35,   +36,    -1,   +33, 
   -1,    -1, 
};

static const int16_t yy_check[62] = {
   -1,    +0,    +2,    +0,    +2,    +0,    +0,    +0,    +0,    +0, 
   +0,    +1,    +6,   +11,    +1,   +11,    +8,    +1,    +8,   +21, 
   +8,    +8,    +8,    +8,    +8,    +8,    +9,    +9,   +23,    +9, 
   +9,    +9,    +9,    +9,    +9,    +9,   +10,   +12,   +27,   +12, 
  +10,   +10,   +24,   +24,   +29,   +24,   +24,   +24,   +24,   +24, 
  +24,   +24,   +28,   +31,   +32,   +28,   +34,   +35,    -1,   +32, 
   -1,    -1, 
};

#line 1 "./src/test/lex/inputs/premature_eof.l"
#include <stdio.h>
#include <string.h>

int line_num = 1;

enum {
	INITIAL = 1507328,
	VALUE = 1638408,
	COMMENT = 1703957,
};


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#define YY_READ_SIZE 16

static char *yy_buffer = NULL;
static size_t yy_buf_size = 0;    // total allocated size
static size_t yy_buf_len = 0;     // number of bytes currently filled
static size_t yy_buf_pos = 0;     // current read position

static char *yytext = NULL;
static int yyleng = 0;

FILE *yyin = NULL; // input stream
FILE *yyout = NULL;

static void buffer_realloc(size_t min_required) {
    size_t new_size = yy_buf_size == 0 ? YY_READ_SIZE : yy_buf_size;

    if (yy_buf_size >= min_required) return ;

    while (new_size < min_required) {
        new_size *= 2;
    }


    char *new_buffer = realloc(yy_buffer, new_size);
    if (!new_buffer) {
        fprintf(stderr, "Out of memory while reallocating buffer\n");
        exit(1);
    }

    yy_buffer = new_buffer;
    yy_buf_size = new_size;
}

static void buffer_join(size_t readSize, char *buffer) {
    if (yy_buf_len + readSize > yy_buf_size) {
        buffer_realloc(yy_buf_size + readSize);
    }

    int i = 0;
    while (i < readSize) {
        yy_buffer[yy_buf_pos + i] = buffer[i];
        i++;
    }
}

static int yy_read_char(void) {
    if (yy_buf_pos >= yy_buf_len) {
        char buffer[YY_READ_SIZE];
        memset(buffer, 0, YY_READ_SIZE);

        int rsize = fread(buffer, 1, YY_READ_SIZE, yyin);
        if (rsize == 0) {
            yy_buffer[yy_buf_pos] = EOF;
        } else {
            buffer_join(rsize, buffer);
        }
        yy_buf_len += rsize;

        if (rsize == 0) return EOF;
    }
    return yy_buffer[yy_buf_pos++];
}

static void yy_unread_char(void) {
    if (yy_buf_pos > 0) yy_buf_pos--;
}

static void yy_free_buffer(void) {
    free(yy_buffer);
    yy_buffer = NULL;
    yy_buf_size = yy_buf_len = yy_buf_pos = 0;
}
static int yy_start;

#define BEGIN(condition) ((yy_start) = (condition))
#define YY_AT_BOL() (yy_buf_pos == 0 || (yy_buf_pos > 0 && yy_buffer[yy_buf_pos - 1] == '\n'))
#define YY_BOL() ((yy_start >> 16))
static inline int yy_action(int accept_id) {
    switch (accept_id) {
        case 1:
{
    printf("[Line %d] Key: %s\n", line_num, yytext);
    BEGIN(VALUE);  // Switch to VALUE mode
}
        break;
        case 2:
{
    BEGIN(COMMENT);
}
        break;
        case 3:
{
    line_num++;
    BEGIN(INITIAL);
}
        break;
        case 4:
{ /* ignore */ }
        break;
        case 5:
{ line_num++; }
        break;
        case 6:
{
    printf("[Line %d] Value (quoted string): %s\n", line_num, yytext);
    BEGIN(INITIAL);
}
        break;
        case 7:
{
    printf("[Line %d] Value (number): %s\n", line_num, yytext);
    BEGIN(INITIAL);
}
        break;
        case 8:
{
    printf("[Line %d] Value (word): %s\n", line_num, yytext);
    BEGIN(INITIAL);
}
        break;
        case 9:
{
    printf("[Line %d] Invalid value token: %s\n", line_num, yytext);
}
        break;
        case 10:
{
    printf("[Line %d] Unexpected input: %s\n", line_num, yytext);
}
        break;
        default:
            fprintf(stderr, "Unknown action id: %d\n", accept_id);
            break;
        }
    return 0;
}

static inline int yy_next_state(int s, int ec) {
    while (s != -1) {
        if (yy_check[yy_base[s] + ec] == s)
            return yy_next[yy_base[s] + ec];
        s = yy_default[s];
    }
    return s;
}

// --- Core DFA scanning function ---
int yylex(void) {
    BEGIN(INITIAL);

    if (!yyin) yyin = stdin;
    if (!yyout) yyout = stdout;

    while (1) {
        int state = (yy_start & 0xFFFF);
        int bol_state = YY_AT_BOL() ? YY_BOL() : -1;

        int default_las = -1;
        int default_lap = -1;
        int bol_las = -1;
        int bol_lap = -1;

        int start_pos = yy_buf_pos;
        int cur_pos = start_pos;
        int last_read_c = -1;
        // printf("state: %d, bol_state: %d\n", state, bol_state);

        while (1) {
            last_read_c = yy_read_char();
            /*printf("Read: %d %d at pos: %d\n", last_read_c, last_read_c, yy_buf_pos);*/

            if (last_read_c == EOF) break;
            last_read_c = (unsigned char) last_read_c;

            int sym = yy_ec[last_read_c];

            int next_state = yy_next_state(state, sym);
            int bol_next_state = yy_next_state(bol_state, sym);

            // printf("bol_next_state: %d, next_state: %d\n", bol_state, next_state);

            if (next_state < 0 && bol_state < 0) break;

            state = next_state;
            bol_state = bol_next_state;
            cur_pos = yy_buf_pos;

            if (bol_state != -1 && yy_accept[bol_state] > 0) {
                bol_las = bol_state;
                bol_lap = cur_pos;
                /*printf("Match bol with: %d %d\n", default_las, default_lap);*/
            }

            if (state != -1 && yy_accept[state] > 0) {
                default_las = state;
                default_lap = cur_pos;
                /*printf("Match normal with: %d %d\n", default_las, default_lap);*/
            }
        }

        if (bol_las > 0) {
            if (bol_lap > default_lap) {
                default_las = bol_las;
                default_lap = bol_lap;
            } else if (bol_lap == default_lap && yy_accept[bol_las] < yy_accept[default_las]) {
                default_las = bol_las;
                default_lap = bol_lap;
            }
        }


        /*printf("buf_pos: %d, default_lap: %d, default_las: %d\n", yy_buf_pos, default_lap, default_las);*/
        if (default_las > 0) {
            // Backtrack
            while (yy_buf_pos > default_lap) {
                /*printf("pos: %d, default_lap: %d\n", yy_buf_pos, default_lap);*/
                yy_unread_char();
            }

            int accept_id = yy_accept[default_las];

            if (yy_acclist[accept_id] != 0) {
                while (yy_buf_pos > start_pos) yy_unread_char();

                // printf("Started backtraking\n");
                int tc_state = yy_acclist[accept_id];
                int tc_las = -1;
                int tc_lap = -1;

                int tc_cur_pos = start_pos;
                int last_read_c = -1;

                while (1) {
                    last_read_c = yy_read_char();
                    if (last_read_c == EOF) break;

                    last_read_c = (unsigned char) last_read_c;

                    int sym = yy_ec[last_read_c];
                    int next_state = yy_next_state(tc_state, sym);

                    if (next_state < 0) break;

                    tc_state = next_state;
                    tc_cur_pos = yy_buf_pos;

                    if (yy_accept[tc_state] > 0) {
                        tc_las = tc_state;
                        tc_lap = tc_cur_pos;
                    }
                }
                while (yy_buf_pos > tc_lap) yy_unread_char();
                default_lap = tc_lap;
            }

            yyleng = default_lap - start_pos;
            yytext = &yy_buffer[start_pos];

            //Save the last read character, in case yytext is used as a string in any action
            unsigned char yy_hold_char = yytext[yyleng];
            yytext[yyleng] = '\0'; 

            yy_action(accept_id);

            yytext[yyleng] = yy_hold_char;
            // printf("Continue\n");
            continue;
        }

        //DO BEFORE ACTION
        yytext = &yy_buffer[start_pos];
        yyleng = (int) (yy_buf_pos - start_pos);

        //ECHO
        fwrite(yytext, yyleng, 1, yyout);
        if (yy_buffer[yy_buf_pos] == EOF) break;
    }

    yy_free_buffer();
    fclose(yyout);
    fclose(yyin);

    return 0;
}

int main(int ac, char *av[]) {
    ++av; --ac;
    if (ac > 0) {
        yyin = fopen(*av, "r");
    } else {
        yyin = fopen("test.lang", "r");
    }
    yyout = stdout;
    yylex();
}

